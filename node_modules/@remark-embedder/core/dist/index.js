"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _parse = _interopRequireDefault(require("parse5"));

var _hastUtilFromParse = _interopRequireDefault(require("hast-util-from-parse5"));

var _unistUtilVisit = _interopRequireDefault(require("unist-util-visit"));

// results in an AST node of type "root" with a single "children" node of type "element"
// so we return the first (and only) child "element" node
const htmlToHast = string => (0, _hastUtilFromParse.default)(_parse.default.parseFragment(string)).children[0];

const getUrlString = url => {
  const urlString = url.startsWith('http') ? url : `https://${url}`;

  try {
    return new URL(urlString).toString();
  } catch (error) {
    return null;
  }
};

function remarkEmbedder({
  transformers,
  cache
}) {
  // convert the array of transformers to one with both the transformer and the config tuple
  const transformersAndConfig = transformers.map(t => {
    if (Array.isArray(t)) return {
      transformer: t[0],
      config: t[1]
    };else return {
      transformer: t
    };
  });
  return async function (tree) {
    const nodeAndURL = [];
    (0, _unistUtilVisit.default)(tree, 'paragraph', paragraphNode => {
      if (paragraphNode.children.length !== 1) {
        return;
      }

      const {
        children
      } = paragraphNode;
      const node = children[0];
      const isText = node.type === 'text'; // it's a valid link if there's no title, and the value is the same as the URL

      const isValidLink = node.type === 'link' && node.title === null && node.children.length === 1 && node.children[0].value === node.url;

      if (!isText && !isValidLink) {
        return;
      }

      const {
        url,
        value = url
      } = node;
      const urlString = getUrlString(value);

      if (!urlString) {
        return;
      }

      nodeAndURL.push({
        parentNode: paragraphNode,
        url: urlString
      });
    });
    const nodesToTransform = [];

    for (const node of nodeAndURL) {
      for (const transformerAndConfig of transformersAndConfig) {
        // we need to make sure this is completed in sequence
        // because the order matters
        // eslint-disable-next-line no-await-in-loop
        if (await transformerAndConfig.transformer.shouldTransform(node.url)) {
          nodesToTransform.push({ ...node,
            ...transformerAndConfig
          });
          break;
        }
      }
    }

    const promises = nodesToTransform.map(async ({
      parentNode,
      url,
      transformer,
      config
    }) => {
      try {
        const cacheKey = `remark-embedder:${transformer.name}:${url}`;
        let html = await (cache == null ? void 0 : cache.get(cacheKey));

        if (!html) {
          html = await transformer.getHTML(url, config);
          await (cache == null ? void 0 : cache.set(cacheKey, html));
        } // if nothing's returned from getHTML, then no modifications are needed


        if (!html) return; // convert the HTML string into an AST

        const htmlElement = htmlToHast(html); // set the parentNode.data with the necessary properties

        parentNode.data = {
          hName: htmlElement.tagName,
          hProperties: htmlElement.properties,
          hChildren: htmlElement.children
        };
      } catch (e) {
        // https://github.com/microsoft/TypeScript/issues/20024#issuecomment-344511199
        const error = e;
        error.message = `The following error occurred while processing \`${url}\` with the remark-embedder transformer \`${transformer.name}\`:\n\n${error.message}`;
        throw error;
      }
    });
    await Promise.all(promises);
    return tree;
  };
}

var _default = remarkEmbedder;
/*
eslint
  @typescript-eslint/no-explicit-any: "off",
*/

exports.default = _default;